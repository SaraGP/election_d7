<?php
/**
 * @file
 * Election Vote: primary module file.
 */

/**
 * Implements hook_menu().
 */
function election_vote_menu() {
  $items = array();

  $items['election-post/%election_post/vote'] = array(
    'title' => 'Vote',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_vote_form', 1),
    'access callback' => 'election_vote_access',
    'access arguments' => array('vote', 1),
    'type' => MENU_CALLBACK,
  );

  $items['election-post/%election_post/vote/undo'] = array(
    'title' => 'Undo',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_vote_undo_form', 1),
    'access callback' => 'election_vote_access',
    'access arguments' => array('undo', 1),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function election_vote_permission() {
  return array(
    'vote in elections' => array(
      'title' => t('Vote in elections'),
      'description' => t('Users must have this permission in order to vote.'),
    ),
    'undo own vote' => array(
      'title' => t('Undo own vote'),
      'description' => t('This allows users to undo their own vote.'),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function election_vote_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_theme().
 */
function election_vote_theme() {
  return array(
    'election_vote_confirm' => array(
      'variables' => array(
        'form_state' => NULL,
      ),
      'file' => 'election_vote.theme.inc',
    ),
    'election_vote_eligibility' => array(
      'variables' => array(
        'post' => NULL,
        'account' => NULL,
      ),
      'file' => 'election_vote.theme.inc',
    ),
    'election_vote_button' => array(
      'variables' => array(
        'post' => NULL,
      ),
      'file' => 'election_vote.theme.inc',
    ),
  );
}

/**
 * Access callback for voting.
 *
 * @param string $op
 *   The operation requested (e.g. 'vote').
 * @param stdClass $post
 *   The election post object.
 */
function election_vote_access($op, stdClass $post, $account = NULL) {
  if (empty($account)) {
    $account = $GLOBALS['user'];;
  }
  // Allow other modules to block access using hook_election_vote_access().
  $hook_results = module_invoke_all('election_vote_access', $op, $post, $account);
  foreach ($hook_results as $hook_result) {
    if ($hook_result === FALSE) {
      return FALSE;
    }
  }
  $election = $post->election;
  switch ($op) {
    case 'vote':
      // Check whether the election is open.
      if (!_election_is_open($election->vstatus, $election->vopen_time, $election->vclose_time)) {
        return FALSE;
      }
      // Check whether the post is individually set to 'closed'.
      switch ($post->vstatus_inheritance) {
        case ELECTION_POST_STATUS_CLOSED:
          return FALSE;
          break;

      }
      // Check role access.
      $accounts_roles_with_access = array_intersect(array_keys($account->roles), (array) $post->rids);
      if (!count($accounts_roles_with_access)) {
        return FALSE;
      }
      return TRUE;
      break;

    case 'undo':
      // Don't allow undo if the user can no longer vote at all.
      if (!election_vote_access('vote', $post, $account)) {
        return FALSE;
      }
      return user_access('undo own vote');
      break;

  }
  return FALSE;
}

/**
 * Implements hook_hook_info().
 */
function election_vote_hook_info() {
  return array(
    'election_vote_access' => array(
      'group' => 'election',
    ),
  );
}

/**
 * Implements hook_entity_delete().
 */
function election_vote_entity_delete($entity, $type) {
  switch ($type) {
    // Delete associated votes when a post is deleted.
    case 'election_post':
      db_query('DELETE FROM {election_vote} WHERE post_id = :pid', array(':pid' => $entity->post_id));
      db_query('DELETE FROM {election_ballot} WHERE post_id = :pid', array(':pid' => $entity->post_id));
      break;

  }
}

/**
 * Form builder function for election-post/%election_post/vote.
 */
function election_vote_form($form, &$form_state, stdClass $post) {

  if (isset($form_state['vote_require_confirm'])) {
    return election_vote_form_vote_confirm($form, $form_state);
  }

  if (isset($form_state['abstain_require_confirm'])) {
    return election_vote_form_abstain_confirm($form, $form_state);
  }

  $election = $post->election;

  $title = election_post_page_title($post);
  drupal_set_title(
    t('Vote: %title_trim', array(
      '%title_trim' => truncate_utf8($post->title, 50, TRUE, TRUE),
    )),
    PASS_THROUGH
  );
  drupal_set_breadcrumb(
    _election_build_breadcrumb($election, l($post->title, election_post_uri_path($post)))
  );

  $form_state['election'] = $election;
  $form_state['post'] = $post;

  if ($previously_voted = election_vote_check_account_previously_voted($post)) {
    if (election_vote_access('undo', $post)) {
      drupal_goto(election_post_uri_path($post) . '/vote/undo');
      return;
    }
    else {
      drupal_set_message(t(
        'You have already voted (or abstained from) this @post_name.',
        array('@post_name' => election_get_post_name($election->type)),
        'status',
        FALSE
      ));
      drupal_goto(election_post_uri_path($post));
      return;
    }
  }
  else {
    // At this stage it's safe to assume the user has not voted.
    // The session-based check can therefore be cleared if it exists.
    $_SESSION['election_vote_cast_' . $post->post_id] = FALSE;
  }

  $form['buttons'] = array(
    '#type' => 'actions',
    '#weight' => 100,
  );
  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Vote…'),
    '#submit' => array('election_vote_form_vote'),
  );

  if (!empty($post->allow_abstention)) {
    $form['buttons']['abstain'] = array(
      '#type' => 'submit',
      '#value' => t('Abstain…'),
      '#submit' => array('election_vote_form_abstain'),
      '#limit_validation_errors' => array(),
    );
  }

  $form['#attached']['js'][] = drupal_get_path('module', 'election') . '/submit-single.min.js';

  $type = $election->type_info;
  if (!empty($type['vote form']) && function_exists($type['vote form'])) {
    $function = $type['vote form'];
    $form = $function($form, $form_state, $post, $election);
  }

  return $form;

}

/**
 * Submit callback for the 'Vote' button on the vote form.
 */
function election_vote_form_vote_confirm($form, &$form_state) {

  $form['vote_confirmed'] = array(
    '#type' => 'hidden',
    '#value' => TRUE,
  );

  $form['#submit'] = array('election_vote_form_vote');

  $form['#attached']['js'][] = drupal_get_path('module', 'election') . '/submit-single.min.js';

  // confirm_form() ignores its third argument when $_GET['destination'] is set.
  unset($_GET['destination']);

  return confirm_form(
    $form,
    t('Are you sure you want to cast this vote?'),
    current_path(),
    theme('election_vote_confirm', array('form_state' => $form_state)),
    t('Confirm'),
    t('Cancel')
  );

}

/**
 * Form for undoing a vote (or abstention).
 */
function election_vote_undo_form($form, &$form_state, $post) {

  $election = $post->election;
  $post_name = election_get_post_name($election->type);

  $form_state['post'] = $post;
  $form_state['election'] = $election;

  drupal_set_breadcrumb(
    _election_build_breadcrumb(
      $election,
      l($post->title, election_post_uri_path($post))
    )
  );

  if (isset($form_state['undo_require_confirm'])) {
    return election_vote_undo_confirm($form, $form_state);
  }

  $form['post'] = array(
    '#type' => 'item',
    '#title' => drupal_ucfirst($post_name),
    '#markup' => check_plain($post->title),
  );
  $form['warning'] = array(
    '#type' => 'item',
    '#markup' => t(
      'You have already voted !or_abstained.',
      array(
        '@post_name' => $post_name,
        '!or_abstained' => $post->allow_abstention ? t('or abstained') : '',
      )
    ),
  );
  $form['undo'] = array(
    '#type' => 'item',
    '#markup' => t(
      'If you wish, you can \'undo\' this action. This means you could vote !or_abstain again.',
      array(
        '!or_abstention' => $post->allow_abstention ? t('or abstention') : '',
        '!or_abstain' => $post->allow_abstention ? t('(or abstain)') : '',
      )
    ),
  );
  $form['actions'] = array(
    '#type' => 'actions',
  );
  $form['actions']['undo'] = array(
    '#type' => 'submit',
    '#value' => t('Undo…'),
    '#submit' => array('election_vote_undo'),
    '#limit_validation_errors' => array(),
  );
  $form['actions']['return_election'] = array(
    '#type' => 'link',
    '#title' => t('Return to %election', array('%election' => $election->title)),
    '#href' => election_uri_path($election),
    '#options' => array('html' => TRUE),
  );
  return $form;
}

/**
 * Confirm the 'Undo vote' button on the Undo vote form.
 */
function election_vote_undo_confirm($form, &$form_state) {

  $form['undo_confirmed'] = array(
    '#type' => 'hidden',
    '#value' => TRUE,
  );

  $form['#submit'] = array('election_vote_undo');

  $form['#attached']['js'][] = drupal_get_path('module', 'election') . '/submit-single.min.js';

  // confirm_form() ignores its third argument when $_GET['destination'] is set.
  unset($_GET['destination']);

  $post = $form_state['post'];
  $election = $form_state['election'];

  return confirm_form(
    $form,
    t('Undo: are you sure?'),
    current_path(),
    t('This will undo your vote !or_abstention for the @post_name %post.', array(
      '@post_name' => election_get_post_name($election->type),
      '%post' => $post->title,
      '!or_abstention' => $post->allow_abstention ? t('or abstention') : '',
    )),
    t('Confirm'),
    t('Cancel')
  );

}

/**
 * Submit callback for confirming undo on an election vote.
 */
function election_vote_undo($form, &$form_state) {

  if (empty($form_state['values']['undo_confirmed'])) {
    $form_state['undo_require_confirm'] = TRUE;
    $form_state['rebuild'] = TRUE;
    return;
  }

  $post = $form_state['post'];
  $election = $form_state['election'];

  $success = FALSE;

  $transaction = db_transaction();

  try {

    $ballot_ids = db_select('election_ballot', 'eb')
      ->fields('eb', array('ballot_id'))
      ->condition('uid', $GLOBALS['user']->uid)
      ->condition('post_id', $post->post_id)
      ->execute()
      ->fetchCol();

    if (!count($ballot_ids)) {
      throw new Exception(t('No votes found.'));
    }

    db_delete('election_vote')
      ->condition('ballot_id', $ballot_ids, 'IN')
      ->execute();

    db_delete('election_ballot')
      ->condition('ballot_id', $ballot_ids, 'IN')
      ->execute();

    $success = TRUE;

  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('election_vote', $e, NULL, WATCHDOG_ERROR);
  }

  if ($success) {

    $post_name = election_get_post_name($election->type);
    drupal_set_message(
      t('You have undone your vote !or_abstention for the @post_name !post_link.', array(
        '@post_name' => $post_name,
        '!post_link' => l($post->title, election_post_uri_path($post)),
        '!or_abstention' => $post->allow_abstention ? t('or abstention') : '',
      ))
    );

    watchdog(
      'election_vote',
      'User @uid has undone a vote for %post_title (@pid) in %election_title (@eid).',
      array(
        '@uid' => $GLOBALS['user']->uid,
        '%post_title' => $post->title,
        '%election_title' => $election->title,
        '@pid' => $post->post_id,
        '@eid' => $election->election_id,
      )
    );

    $form_state['redirect'] = url(election_post_uri_path($post));

  }

}

/**
 * Confirm the 'Abstain' button on the vote form.
 */
function election_vote_form_abstain_confirm($form, &$form_state) {

  $form['abstain_confirmed'] = array(
    '#type' => 'hidden',
    '#value' => TRUE,
  );

  $form['#submit'] = array('election_vote_form_abstain');

  $form['#attached']['js'][] = drupal_get_path('module', 'election') . '/submit-single.min.js';

  // confirm_form() ignores its third argument when $_GET['destination'] is set.
  unset($_GET['destination']);

  $post = $form_state['post'];

  // @todo Make this confirmation page themeable.
  $warning = t('This action cannot be undone.');
  if (election_vote_access('undo', $post)) {
    $warning = '';
  }

  return confirm_form(
    $form,
    t('Are you sure you want to abstain?'),
    current_path(),
    $warning
  );

}

/**
 * Submit callback for the 'Abstain' button on the vote form.
 */
function election_vote_form_abstain($form, &$form_state) {

  if (empty($form_state['values']['abstain_confirmed'])) {
    $form_state['abstain_require_confirm'] = TRUE;
    $form_state['rebuild'] = TRUE;
    return;
  }

  $post = $form_state['post'];
  $election = $form_state['election'];

  // Check to prevent duplicate form submissions.
  if (!empty($_SESSION['election_vote_cast_' . $post->post_id])) {
    $form_state['redirect'] = url(election_uri_path($election));
    return;
  }

  $success = FALSE;

  $transaction = db_transaction();

  try {

    $ballot = array(
      'election_id' => $election->election_id,
      'post_id' => $post->post_id,
      'uid' => $GLOBALS['user']->uid,
      'ip' => ip_address(),
      'agent' => $_SERVER['HTTP_USER_AGENT'],
      'sid_hash' => _election_vote_session_hash(),
      'timestamp' => REQUEST_TIME,
    );
    $ballot_id = db_insert('election_ballot')
      ->fields($ballot)
      ->execute();
    if (empty($ballot_id)) {
      throw new Exception('The vote record could not be saved.');
    }

    $vote = array(
      'ballot_id' => $ballot_id,
      'election_id' => $election->election_id,
      'post_id' => $post->post_id,
      'abstain' => 1,
    );
    $success = db_insert('election_vote')
      ->fields($vote)
      ->execute();

  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('election_vote', $e, NULL, WATCHDOG_ERROR);
  }

  if ($success) {

    // Save a session variable to prevent duplicate form submissions.
    $_SESSION['election_vote_cast_' . $post->post_id] = TRUE;

    $post_name = election_get_post_name($election->type);
    drupal_set_message(
      t('You have abstained from voting for the @post_name !post_link.', array(
        '@post_name' => $post_name,
        '!post_link' => l($post->title, election_post_uri_path($post)),
      ))
    );

    $form_state['redirect'] = url(election_uri_path($election));

    // Invoke "After abstaining" rules.
    if (module_exists('rules')) {
      rules_invoke_event('election_vote_abstain', $GLOBALS['user'], $post, $election);
    }

  }

}

/**
 * Submit callback for the 'Vote' button on the form election_vote_form_confirm.
 */
function election_vote_form_vote($form, &$form_state) {

  if (empty($form_state['values']['vote_confirmed'])) {
    $form_state['vote_require_confirm'] = TRUE;
    $form_state['rebuild'] = TRUE;
    return;
  }

  $post = $form_state['post'];
  $election = $form_state['election'];

  $success = FALSE;

  // Check to prevent duplicate form submissions.
  if (!empty($_SESSION['election_vote_cast_' . $post->post_id])) {
    $form_state['redirect'] = url(election_uri_path($election));
    return;
  }

  $transaction = db_transaction();

  try {

    $ballot = array(
      'election_id' => $election->election_id,
      'post_id' => $post->post_id,
      'uid' => $GLOBALS['user']->uid,
      'ip' => ip_address(),
      'agent' => $_SERVER['HTTP_USER_AGENT'],
      'sid_hash' => _election_vote_session_hash(),
      'timestamp' => REQUEST_TIME,
    );
    $ballot_id = db_insert('election_ballot')
      ->fields($ballot)
      ->execute();
    if (empty($ballot_id)) {
      throw new Exception('The vote record could not be saved.');
    }

    $type = $election->type_info;
    if (!empty($type['save votes']) && function_exists($type['save votes'])) {
      $function = $type['save votes'];
      $success = $function($form, $form_state, $post, $ballot_id);
    }

  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('election_vote', $e, NULL, WATCHDOG_ERROR);
  }

  if ($success) {

    // Save a session variable to prevent duplicate form submissions.
    $_SESSION['election_vote_cast_' . $post->post_id] = TRUE;

    // Display a success message to the user.
    $post_name = election_get_post_name($election->type);
    drupal_set_message(
      t('Thank you for voting for the @post_name !post_link.', array(
        '@post_name' => $post_name,
        '!post_link' => l($post->title, election_post_uri_path($post)),
      ))
    );

    $form_state['redirect'] = url(election_uri_path($election));

    // Invoke "After casting a vote" rules.
    if (module_exists('rules')) {
      rules_invoke_event('election_vote_vote', $GLOBALS['user'], $post, $election);
    }

  }

}

/**
 * Find out whether the $account has previously voted for the $post.
 *
 * @param stdClass $post
 *   The election post object.
 * @param stdClass $account
 *   Optional user account object (leave blank for the logged-in user).
 *
 * @return bool
 *   TRUE if previously voted, FALSE otherwise.
 */
function election_vote_check_account_previously_voted($post, $account = NULL) {

  global $user;
  if (empty($account)) {
    $account = $user;
  }
  $account_is_user = ($account->uid == $user->uid);

  // For anonymous users, check the session ID.
  // Of course this is not a 100% reliable identifier of a user.
  // The session ID is hashed, to improve anonymity.
  if ($account_is_user && !user_is_logged_in()) {
    $result = db_query_range('SELECT ballot_id FROM {election_ballot} WHERE uid = 0 AND post_id = :pid AND (sid_hash = :sh OR (ip = :ip AND agent = :agent))', 0, 1, array(
      ':sh' => _election_vote_session_hash(),
      ':ip' => ip_address(),
      ':agent' => $_SERVER['HTTP_USER_AGENT'],
      ':pid' => $post->post_id,
    ))->fetchCol();
    return (!empty($result));
  }

  // Otherwise, check based on the $account->uid.
  $vote_count = db_query(
    'SELECT COUNT(ballot_id) FROM {election_ballot} WHERE uid = :uid AND post_id = :pid',
    array(':uid' => $account->uid, ':pid' => $post->post_id)
  )->fetchField(0);

  return (bool) $vote_count;

}

/**
 * Get a hash of the session ID, in order to track anonymous users anonymously.
 */
function _election_vote_session_hash() {
  $sid = session_id();
  return md5($sid . $GLOBALS['drupal_hash_salt']);
}

/**
 * Implements hook_html_head_alter().
 */
function election_vote_html_head_alter(&$head_elements) {
  // Set robots=noindex,nofollow on voting forms.
  if (preg_match('/election\-post\/[0-9]+\/vote/', current_path())) {
    foreach ($head_elements as $key => $element) {
      if (isset($element['#atributes']['name']) && $element['#attributes']['name'] == 'robots' && $element['#attributes']['content'] != 'noindex,nofollow') {
        unset($head_elements[$key]);
        break;

      }
    }
    $head_elements['robots'] = array(
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => array('name' => 'robots', 'content' => 'noindex,nofollow'),
    );
  }
}

/**
 * Check whether a post has approved candidates.
 *
 * @return bool
 *   TRUE if:
 *     (A) the number of approved candidates > 1
 *     or (B) there is 1 approved candidate, and RON;
 *   FALSE otherwise.
 */
function _election_vote_post_has_approved_candidates($post) {
  $num_candidates = db_query('SELECT COUNT(candidate_id) FROM {election_candidate} WHERE post_id = :pid AND cstatus = :approved', array(':pid' => $post->post_id, ':approved' => ELECTION_CANDIDATE_APPROVED))->fetchField(0);
  $has_ron = !empty($post->settings['use_ron']);
  return ($num_candidates > 1 || ($num_candidates == 1 && $has_ron));
}

/**
 * Determine whether the election post has enough candidates for voting.
 *
 * A post needs to have at least 2 approved candidates (inc. RON) in order for
 * voting to be possible. Otherwise the candidate is unopposed.
 *
 * @see _election_vote_post_has_approved_candidates()
 */
function _election_vote_post_has_enough_candidates($post) {
  if (empty($post->election->type_info['has candidates'])) {
    // Elections that don't support candidates always have 'enough' candidates.
    return TRUE;
  }
  return _election_vote_post_has_approved_candidates($post);
}

/**
 * Implements template_preprocess_election_post().
 */
function election_vote_preprocess_election_post(&$variables) {

  $post = $variables['elements']['#post'];

  $variables['content']['vote_button'] = array(
    '#theme' => 'election_vote_button',
    '#post' => $post,
    '#weight' => -50,
  );

  $variables['content']['eligibility'] = array(
    '#theme' => 'election_vote_eligibility',
    '#post' => $post,
    '#weight' => 10,
  );

}
