<?php
/**
 * @file
 * Election Candidate: primary module file.
 */

// Required files.
require_once 'election_candidate.constants.inc';

/**
 * Implements hook_entity_info().
 */
function election_candidate_entity_info() {

  $entities = array();

  $entities['election_candidate'] = array(
    'label' => t('Election candidate'),
    'access callback' => 'election_candidate_access',
    'uri callback' => 'election_candidate_uri',
    'controller class' => 'ElectionCandidateController',
    'base table' => 'election_candidate',
    'label callback' => 'election_candidate_label',
    'entity keys' => array(
      'id' => 'candidate_id',
      'bundle' => 'type',
    ),
    'static cache' => TRUE,
    'fieldable' => TRUE,
    'module' => 'election',
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
      ),
      'teaser' => array(
        'label' => t('Teaser'),
      ),
      'details' => array(
        'label' => t('Details'),
        'custom settings' => TRUE,
      ),
    ),
    'view callback' => 'entity_metadata_view_single',
    // Disable fields added by the Redirect module.
    'redirect' => FALSE,
  );

  // The entity that holds information about candidate types.
  $entities['election_candidate_type'] = array(
    'label' => t('Candidate type'),
    'entity class' => 'ElectionCandidateType',
    'controller class' => 'ElectionCandidateTypeController',
    'base table' => 'election_candidate_type',
    'fieldable' => FALSE,
    'bundle of' => 'election_candidate',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type',
      'label' => 'label',
    ),
    'access callback' => 'election_candidate_type_access',
    'module' => 'election_candidate',
    'admin ui' => array(
      'path' => 'admin/config/election/candidate-types',
      'file' => 'election_candidate_type.admin.inc',
      'controller class' => 'ElectionCandidateTypeUIController',
    ),
  );

  return $entities;

}

/**
 * Implements hook_entity_info_alter().
 */
function election_candidate_entity_info_alter(&$entity_info) {

  // Add configuration for candidate types (bundles).
  foreach (election_candidate_get_types() as $type => $info) {
    $entity_info['election_candidate']['bundles'][$type] = array(
      'label' => $info->label,
      'admin' => array(
        'path' => 'admin/config/election/candidate-types/manage/%election_candidate_type',
        'real path' => 'admin/config/election/candidate-types/manage/' . $type,
        'bundle argument' => 5,
        'access arguments' => array('administer candidate types'),
      ),
    );
  }
}

/**
 * Get a list of defined candidate types.
 */
function election_candidate_get_types($type_name = NULL) {
  $types = entity_load_multiple_by_name('election_candidate_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Define the default election candidate types.
 *
 * @see http://drupal.org/node/999942
 *
 * @return array
 *   An array of default candidate types, keyed by machine names.
 */
function election_candidate_default_election_candidate_type() {
  $defaults['candidate'] = entity_create('election_candidate_type', array(
    'type' => 'candidate',
    'label' => t('Candidate (default type)'),
  ));
  return $defaults;
}

/**
 * Implements hook_permission().
 */
function election_candidate_permission() {
  $permissions = array(
    'administer candidate types' => array(
      'title' => t('Administer candidate types'),
      'description' => t('This allows the user to add/edit/delete candidate types, and manage field and display settings for candidates.'),
    ),
    'bypass nomination schedule' => array(
      'title' => t('Bypass nomination schedule'),
      'description' => t('This allows the user to submit a nomination at any time, regardless of whether or not nominations are open.'),
    ),
    'bypass nomination exclusivity' => array(
      'title' => t('Bypass nomination exclusivity'),
      'description' => t('This allows the user to submit a nomination for more than one exclusive position.'),
    ),
    'allow duplicate nominations' => array(
      'title' => t('Allow duplicate nominations'),
      'description' => t('This allows the user to submit more than one nomination for the same position.'),
    ),
    'submit nominations' => array(
      'title' => t('Submit nominations'),
      'description' => t('This allows the user to submit a nomination, provided nominations are open.'),
    ),
    'edit own nominations' => array(
      'title' => t('Edit own nominations'),
      'description' => t('This allows the user to edit his/her own nominations.'),
    ),
  );
  return $permissions;
}

/**
 * Determines whether the given user has access to a given election candidate.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update').
 * @param stdClass $candidate
 *   Optionally a candidate to check access for. If nothing is
 *   given, access for all candidates is determined.
 * @param stdClass $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return bool
 *   Whether access is allowed or not.
 */
function election_candidate_access($op, $candidate = NULL, $account = NULL) {
  if ($account === NULL) {
    $account = $GLOBALS['user'];
  }
  $election = NULL;
  if (!empty($candidate)) {
    $election = election_load($candidate->election_id);
  }
  switch ($op) {
    case 'view':
      // Users who can edit elections can also view the candidates.
      if (election_access('edit', $election, $account)) {
        return TRUE;
      }
      // Users who can view the election can also view published candidates.
      if (election_access('view', $election, $account) && (empty($candidate) || $candidate->published)) {
        return TRUE;
      }
      break;

    case 'edit':
    case 'update':
    case 'delete':
      if (election_access('edit', $election, $account)) {
        return TRUE;
      }
      break;

  }
  // Deal with candidates that belong to the current user.
  $own = ($account->uid != 0 && !empty($candidate) && $candidate->uid == $account->uid);
  if ($own) {
    switch ($op) {
      case 'view':
        // Users are always allowed to see their own nominations.
        return TRUE;
        break;

      case 'edit':
      case 'update':
        return (bool) user_access('edit own nominations', $account);
        break;

    }
  }
  return FALSE;
}

/**
 * Helper function to allow determining candidate access per election.
 */
function election_candidate_access_per_election($op, stdClass $election, $account = NULL) {
  // Check whether the election supports candidates at all.
  if (!election_candidate_check_support($election)) {
    return FALSE;
  }
  // Defer to the election access system.
  return election_access($op, $election, $account);
}

/**
 * Implements hook_menu().
 */
function election_candidate_menu() {
  $items = array();

  $items['election-post/%election_post/nomination-form'] = array(
    'title' => 'Nomination form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_nomination_form', 1),
    'access callback' => 'election_candidate_nominate_access',
    'access arguments' => array(1),
    'file' => 'election_candidate.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 4,
  );

  $items['election/%election/candidates'] = array(
    'title' => 'Candidates',
    'page callback' => 'election_candidate_list_page',
    'page arguments' => array(1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('view', 1),
    'file' => 'election_candidate.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['election/%election/candidates-admin'] = array(
    'title' => 'Manage candidates',
    'page callback' => 'election_candidate_manage_page',
    'page arguments' => array(1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('edit', 1),
    'file' => 'election_candidate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['election/%election/candidates-admin/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['election/%election/candidates-admin/totals'] = array(
    'title' => 'Totals',
    'page callback' => 'election_candidate_totals_page',
    'page arguments' => array(1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('edit', 1),
    'file' => 'election_candidate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['election/%election/candidates-admin/download'] = array(
    'title' => 'Download',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_download_form', 1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('edit', 1),
    'file' => 'election-candidate.download.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['election-candidate/%election_candidate'] = array(
    'title callback' => 'election_candidate_page_title',
    'title arguments' => array(1),
    'page callback' => 'election_candidate_page_view',
    'page arguments' => array(1),
    'file' => 'election_candidate.pages.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('view', 1),
    'type' => MENU_CALLBACK,
  );

  $items['election-candidate/%election_candidate/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['election-candidate/%election_candidate/details'] = array(
    'title' => 'Details',
    'page callback' => 'election_candidate_page_view',
    'page arguments' => array(1, 'details'),
    'file' => 'election_candidate.pages.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('edit', 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 1,
  );

  $items['election-candidate/%election_candidate/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_edit_form', 1),
    'file' => 'election_candidate.forms.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 2,
  );

  $items['election-candidate/%election_candidate/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_edit_form_delete_confirm', 1),
    'access callback' => 'election_candidate_access',
    'access arguments' => array('delete', 1),
    'file' => 'election_candidate.forms.inc',
    'weight' => 3,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  return $items;
}

/**
 * Implements hook_entity_property_info().
 */
function election_candidate_entity_property_info() {
  $info = array();
  // Add metadata about candidate properties.
  $properties = &$info['election_candidate']['properties'];
  $properties = array(
    'candidate_id' => array(
      'label' => t('Candidate ID'),
      'description' => t('Primary key: the unique identifier for a candidate.'),
      'schema field' => 'candidate_id',
    ),
    'election_id' => array(
      'label' => t('Election ID'),
      'description' => t('The election for this candidate.'),
      'type' => 'election',
      'schema field' => 'election_id',
      'required' => TRUE,
    ),
    'post_id' => array(
      'label' => t('Post ID'),
      'description' => t('The post for which the candidate is standing.'),
      'type' => 'election_post',
      'schema field' => 'post_id',
      'setter callback' => 'entity_property_verbatim_set',
      'required' => TRUE,
    ),
    'type' => array(
      'label' => t('Type'),
      'type' => 'token',
      'required' => TRUE,
      'schema field' => 'type',
    ),
    'published' => array(
      'label' => t('Published status'),
      'type' => 'integer',
      'schema field' => 'published',
      'required' => TRUE,
    ),
    'cstatus' => array(
      'label' => t('Candidate status'),
      'type' => 'integer',
      'options list' => '_election_candidate_get_cstatus_options',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'cstatus',
      'required' => TRUE,
    ),
    'uid' => array(
      'label' => t('User'),
      'description' => t('The user associated with the candidate.'),
      'type' => 'user',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'uid',
    ),
    'first_name' => array(
      'label' => t('First name'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'first_name',
      'required' => TRUE,
    ),
    'last_name' => array(
      'label' => t('Last name'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'last_name',
      'required' => TRUE,
    ),
    'mail' => array(
      'label' => t('Email address'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'mail',
      'required' => TRUE,
    ),
    'created' => array(
      'label' => t('Created time'),
      'type' => 'date',
      'schema field' => 'created',
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'changed' => array(
      'label' => t('Last modified time'),
      'type' => 'date',
      'schema field' => 'changed',
      'setter callback' => 'entity_property_verbatim_set',
    ),
  );
  return $info;
}

/**
 * Get an array of possible candidate statuses.
 */
function _election_candidate_get_cstatus_options() {
  return array(
    ELECTION_CANDIDATE_ELECTED => t('Elected'),
    ELECTION_CANDIDATE_HOPEFUL => t('Hopeful'),
    ELECTION_CANDIDATE_WITHDRAWN => t('Withdrawn'),
    ELECTION_CANDIDATE_REJECTED => t('Rejected'),
    ELECTION_CANDIDATE_DEFEATED => t('Defeated'),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function election_candidate_field_extra_fields() {
  $extra = array(
    'form' => array(
      'post' => array(
        'label' => t('Post'),
        'description' => t('The post for this nomination.'),
        'weight' => 0,
      ),
      'first_name' => array(
        'label' => t('First name'),
        'description' => t("The candidate's first name(s)."),
        'weight' => 1,
      ),
      'last_name' => array(
        'label' => t('Last name'),
        'description' => t("The candidate's last name(s)."),
        'weight' => 2,
      ),
      'mail' => array(
        'label' => t('Email address'),
        'description' => t("The candidate's email address."),
        'weight' => 3,
      ),
    ),
    'display' => array(
      'election' => array(
        'label' => t('Election'),
        'description' => t('The election for this candidate.'),
        'weight' => 0,
      ),
      'post' => array(
        'label' => t('Post'),
        'description' => t('The post/position for this candidate.'),
        'weight' => 1,
      ),
      'status' => array(
        'label' => t('Status'),
        'description' => t("The candidate's status."),
        'weight' => 2,
      ),
    ),
  );
  // Add the above $extra array to every election_candidate bundle.
  $info['election_candidate'] = array();
  foreach (election_candidate_get_types() as $bundle => $type) {
    $info['election_candidate'][$bundle] = $extra;
  }
  return $info;
}

/**
 * Implements hook_field_extra_fields_alter().
 */
function election_candidate_field_extra_fields_alter(&$info) {
  foreach (election_types() as $machine_name => $type) {
    $bundle = $type['post machine name'];
    if (!empty($type['has candidates'])) {
      // Add a property to the 'Manage fields' form for election posts.
      $info['election_post'][$bundle]['form'] += array(
        'candidates_nominations' => array(
          'label' => t('Candidates and nominations'),
          'weight' => 80,
        ),
      );
      // Add a property to the 'Manage display' form for elections.
      $info['election'][$machine_name]['display'] += array(
        'nstatus' => array(
          'label' => t('Nominations status'),
          'weight' => -2,
        ),
      );
      // Add a property to the 'Manage display' form for election posts.
      $info['election_post'][$bundle]['display'] += array(
        'candidates' => array(
          'label' => t('Candidates'),
          'weight' => 100,
        ),
      );
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add candidate settings to the election post edit form.
 */
function election_candidate_form_election_post_form_alter(&$form, &$form_state) {

  $post = $form_state['post'];
  $election = $form_state['election'];
  if (!election_candidate_check_support($election)) {
    return;
  }

  $form['candidates_nominations'] = array(
    '#type' => 'fieldset',
    '#title' => t('Candidates and nominations'),
    '#collapsible' => TRUE,
  );

  $form['candidates_nominations']['nstatus_inheritance'] = array(
    '#type' => 'radios',
    '#title' => t('Nominations status'),
    '#default_value' => isset($post->nstatus_inheritance) ? $post->nstatus_inheritance : ELECTION_POST_STATUS_INHERIT,
    '#options' => array(
      ELECTION_POST_STATUS_INHERIT => t(
        'Inherited (currently: %status)',
        array(
          '%status' => strip_tags(
            theme('election_status', array('election' => $election, 'status_prefix' => 'n'))
          ),
        )
      ),
      ELECTION_POST_STATUS_CLOSED => t('Closed'),
    ),
    '#weight' => 20,
  );

  $type_options = array();
  foreach (election_candidate_get_types() as $bundle => $type) {
    // No need to sanitize for 'select' form elements: FAPI does it already.
    $type_options[$bundle] = $type->label;
  }

  $form['candidates_nominations']['settings_candidate_type'] = array(
    '#type' => 'select',
    '#title' => t('Candidate type'),
    '#options' => $type_options,
    '#weight' => -10,
    '#default_value' => isset($post->settings['candidate_type']) ? $post->settings['candidate_type'] : 'candidate',
    '#required' => TRUE,
    '#description' => t('This determines which candidate fields are available (e.g. in the nomination form). This setting does not affect existing candidates.'),
    '#weight' => 10,
  );

  if (user_access('administer candidate types')) {
    $form['candidates_nominations']['settings_candidate_type']['#description'] .= ' '
      . l(
        t('Manage candidate types'),
        'admin/config/election/candidate-types',
        array(
          'attributes' => array('target' => '_blank'),
        )
      );
  }

  $form['candidates_nominations']['settings_exclusive'] = array(
    '#type' => 'checkbox',
    '#title' => t('Exclusive'),
    '#description' => t(
      'A candidate can only stand for one exclusive @post per election.<br /><strong>N.B. if anonymous users are given permission to submit nominations, exclusivity cannot be enforced.</strong>',
      array(
        '@post' => election_get_post_name($election->type),
      )
    ),
    '#default_value' => isset($post->settings['exclusive']) ? $post->settings['exclusive'] : 1,
    '#weight' => 20,
  );

}

/**
 * Title callback for election/%election_candidate/view.
 *
 * @param stdClass $candidate
 *   The election candidate object.
 */
function election_candidate_page_title($candidate) {
  // Output should not be escaped here; it is escaped later in the menu system.
  return $candidate->first_name . ' ' . $candidate->last_name;
}

/**
 * Wrapper function to allow saving an election candidate.
 *
 * @param stdClass $candidate
 *   Election candidate object.
 */
function election_candidate_save($candidate) {
  return entity_get_controller('election_candidate')->save($candidate);
}

/**
 * Wrapper function to allow deleting multiple candidates.
 *
 * @param array $candidate_ids
 *   Array of candidate IDs.
 */
function election_candidate_delete_multiple(array $candidate_ids) {
  return entity_get_controller('election_candidate')->delete($candidate_ids);
}

/**
 * Wrapper function to allow deleting an individual election.
 *
 * @see election_candidate_delete_multiple()
 *
 * @param mixed $candidate_id
 *   Single candidate ID.
 */
function election_candidate_delete($candidate_id) {
  return election_candidate_delete_multiple(array($candidate_id));
}

/**
 * Access callback for candidate types administration.
 */
function election_candidate_type_access($op, $type = NULL, $account = NULL) {
  return user_access('administer candidate types', $account);
}

/**
 * Find the nominations for a specified account.
 *
 * This gets database records for candidates, joined to the election_post table.
 *
 * @param stdClass $election
 *   Election object.
 * @param stdClass $account
 *   Optional user account object (default: current user).
 *
 * @todo Remove this somehow, it's ugly.
 *
 * @return array
 *   An array of records, as objects. Empty array if the $account is anonymous.
 */
function election_candidate_get_nominations(stdClass $election, $account = NULL) {
  $nominations = &drupal_static(__FUNCTION__, array());
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  if ($account->uid == 0) {
    return array();
  }
  if (!isset($nominations[$election->election_id][$account->uid])) {
    $select = db_query(
      'SELECT ec.*, ep.title AS post_title, ep.settings FROM {election_candidate} ec LEFT JOIN {election_post} ep USING (post_id) WHERE ec.uid = :uid AND ep.election_id = :eid',
      array(
        ':eid' => $election->election_id,
        ':uid' => $account->uid,
      )
    );
    $nominations[$election->election_id][$account->uid] = $select->fetchAll();
  }
  return $nominations[$election->election_id][$account->uid];
}

/**
 * Check access to nominating for a post.
 *
 * @param stdClass $post
 *   Election post object.
 * @param stdClass $account
 *   User account object (default: current user).
 *
 * @return array
 *   Array of post IDs.
 */
function election_candidate_nominate_access(stdClass $post, $account = NULL) {
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  $election = $post->election;
  // Check whether the election supports candidates.
  if (!election_candidate_check_support($election)) {
    return FALSE;
  }
  // Check if the user has global permission for submitting nominations.
  if (!user_access('submit nominations', $account)) {
    return FALSE;
  }
  // Check whether nominations are open.
  if (!_election_post_is_open($post, $election, 'n') && !user_access('bypass nomination schedule', $account)) {
    return FALSE;
  }
  // Load the user's previous nominations, if any.
  $nominations = election_candidate_get_nominations($post->election, $account);
  $has_exclusive = FALSE;
  $prev_post_ids = array();
  foreach ($nominations as $nomination) {
    $settings = (array) unserialize($nomination->settings);
    if (!empty($settings['exclusive'])) {
      $has_exclusive = TRUE;
    }
    $prev_post_ids[] = $nomination->post_id;
  }
  // Prevent duplicate nominations for the same post by one account.
  if (!user_access('allow duplicate nominations', $account) && in_array($post->post_id, $prev_post_ids)) {
    return FALSE;
  }
  // Prevent more than one nomination for an 'exclusive' post by one account.
  if (!empty($post->settings['exclusive']) && $has_exclusive && !user_access('bypass nomination exclusivity', $account)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * URI callback for a single election candidate.
 */
function election_candidate_uri($candidate) {
  $path = 'election-candidate/' . $candidate->candidate_id;
  return array(
    'path' => $path,
    'options' => array(),
  );
}

/**
 * Get the path part of the election candidate URI callback as a string.
 *
 * @see election_candidate_uri()
 */
function election_candidate_uri_path($candidate) {
  $uri = election_candidate_uri($candidate);
  return $uri['path'];
}

/**
 * Entity label callback for an election_candidate.
 */
function election_candidate_label(stdClass $entity, $entity_type) {
  return $entity->first_name . ' ' . $entity->last_name;
}

/**
 * Load an individual candidate.
 *
 * @param int $candidate_id
 *   A single election candidate ID.
 * @param bool $reset
 *   Whether to reset the internal cache for election candidate entities.
 *
 * @return stdClass
 *   A stdClass election_candidate object.
 */
function election_candidate_load($candidate_id, $reset = FALSE) {
  $result = election_candidate_load_multiple((array) $candidate_id, $reset);
  if (!is_array($result) || !count($result)) {
    return FALSE;
  }
  return reset($result);
}

/**
 * Load multiple candidates.
 *
 * @param array $candidate_ids
 *   An array of election candidate IDs.
 * @param bool $reset
 *   Whether to reset the internal cache for election candidate entities.
 *
 * @return array
 *   An array of election candidate objects keyed by candidate ID.
 */
function election_candidate_load_multiple(array $candidate_ids = array(), $reset = FALSE) {
  // The $conditions parameter is not used as this is deprecated for D8.
  return entity_load('election_candidate', $candidate_ids, array(), $reset);
}

/**
 * Load a candidate type.
 *
 * @param string $type
 *   The machine-readable name of a candidate type to load.
 *
 * @return mixed
 *   A candidate type array or FALSE if $type does not exist.
 */
function election_candidate_type_load($type) {
  return election_candidate_get_types($type);
}

/**
 * Implements hook_theme().
 */
function election_candidate_theme() {
  return array(
    'election_candidate' => array(
      'render element' => 'elements',
      'template' => 'election-candidate',
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_full_name' => array(
      'variables' => array(
        'candidate' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_ballot_item' => array(
      'variables' => array(
        'candidate' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_status' => array(
      'variables' => array(
        'candidate' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
  );
}

/**
 * Generate an array for rendering the given candidate.
 *
 * @param stdClass $candidate
 *   An election candidate object.
 * @param string $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 *
 * @return array
 *   An array as expected by drupal_render().
 */
function election_candidate_view($candidate, $view_mode = 'full') {

  $election = election_load($candidate->election_id);
  $post = election_post_load($candidate->post_id);

  // Remove previously built content, if it exists.
  $candidate->content = array();

  // Display a link to the election.
  $candidate->content['election'] = array(
    '#theme' => 'election_info_item',
    '#label' => t('Election'),
    '#value' => l($election->title, election_uri_path($election)),
    '#html' => TRUE,
  );

  // Display a link to the post.
  $candidate->content['post'] = array(
    '#theme' => 'election_info_item',
    '#label' => drupal_ucfirst(election_get_post_name($election->type)),
    '#value' => l($post->title, election_post_uri_path($post)),
    '#html' => TRUE,
  );

  // Display the candidate's status.
  $candidate->content['status'] = array(
    '#theme' => 'election_info_item',
    '#label' => t('Status'),
    '#value' => theme('election_candidate_status', array('candidate' => $candidate)),
    '#html' => TRUE,
  );

  // Only display the following information in the 'Details' view.
  if ($view_mode == 'details') {
    $username = theme('username', array('account' => $candidate->uid ? user_load($candidate->uid) : NULL));
    $mailto = l($candidate->mail, 'mailto:' . $candidate->mail, array('absolute' => TRUE));
    // Display the candidate's email address.
    $candidate->content['mail'] = array(
      '#theme' => 'election_info_item',
      '#label' => t('Email address'),
      '#value' => $mailto,
      '#html' => TRUE,
    );
    // Display the candidate's username.
    $candidate->content['username'] = array(
      '#theme' => 'election_info_item',
      '#label' => t('Username'),
      '#value' => $username,
      '#html' => TRUE,
    );
  }

  // Build fields content.
  // In case of a multiple view, node_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('election_candidate', array($candidate->candidate_id => $candidate), $view_mode);
  entity_prepare_view('election_candidate', array($candidate->candidate_id => $candidate));
  $candidate->content += field_attach_view('election_candidate', $candidate, $view_mode);

  $build = $candidate->content;
  // We don't need duplicate rendering info in $candidate->content.
  unset($candidate->content);

  $post = election_post_load($candidate->post_id);

  $build += array(
    '#theme' => 'election_candidate',
    '#candidate' => $candidate,
    '#election' => $election,
    '#post' => $post,
    '#view_mode' => $view_mode,
  );

  // Add contextual links for this candidate, except when the candidate is
  // already being displayed on its own page.
  if (!empty($candidate->candidate_id) && $view_mode != 'full') {
    $build['#contextual_links']['election_candidate'] = array('election-candidate', array($candidate->candidate_id));
  }

  // Allow modules to modify the structured election candidate.
  $type = 'election_candidate';
  drupal_alter(array('election_candidate_view', 'entity_view'), $build, $type);

  return $build;

}

/**
 * Get the human-readable name of the candidate's 'cstatus' property.
 */
function _election_candidate_status_name(stdClass $candidate) {
  $options = _election_candidate_get_cstatus_options();
  return $options[$candidate->cstatus];
}

/**
 * Implements hook_entity_update().
 */
function election_candidate_entity_update($entity, $type) {
  switch ($type) {
    case 'election_candidate':
      if (module_exists('pathauto')) {
        _election_candidate_pathauto_update_alias($entity, 'update');
      }
      break;

  }
}

/**
 * Implements hook_entity_delete().
 */
function election_candidate_entity_delete($entity, $type) {
  switch ($type) {

    case 'election':
      $election_id = $entity->election_id;
      // Delete associated candidates when an election is deleted.
      $candidate_ids = db_query('SELECT candidate_id FROM {election_candidate} WHERE election_id = :eid', array(':eid' => $election_id))->fetchCol();
      election_candidate_delete_multiple($candidate_ids);
      break;

    // Clear the post_id property of candidates when their post is deleted.
    case 'election_post':
      $update = db_update('election_candidate')
        ->fields(array('post_id' => NULL))
        ->condition('post_id', $entity->post_id)
        ->execute();
      break;

    // Delete Pathauto path aliases when a candidate is deleted.
    case 'election_candidate':
      if (function_exists('pathauto_entity_path_delete_all')) {
        pathauto_entity_path_delete_all('election_candidate', $entity);
      }
      break;

  }
}

/**
 * Implements hook_entity_insert().
 */
function election_candidate_entity_insert($entity, $type) {
  switch ($type) {
    case 'election_candidate':
      if (module_exists('pathauto')) {
        _election_candidate_pathauto_update_alias($entity, 'insert');
      }
      break;

    case 'election':
      // Clear the entity info cache.
      // Needed because creating an election also creates candidate bundles.
      entity_info_cache_clear();
      break;

  }
}

/**
 * Implements hook_file_download_access().
 *
 * Allow private files to be downloaded when they are attached to a candidate
 * entity, if the user has permission to view the candidate.
 */
function election_candidate_file_download_access($field, $entity_type, $entity) {
  if ($entity_type == 'election_candidate') {
    return election_candidate_access('view', $entity);
  }
}

/**
 * Update the URL aliases for an individual election candidate.
 *
 * @param stdClass $candidate
 *   An election candidate object.
 * @param string $op
 *   Operation being performed ('insert', 'update' or 'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function _election_candidate_pathauto_update_alias(stdClass $candidate, $op, array $options = array()) {
  // Skip processing if the candidate has no pattern.
  if (!pathauto_pattern_load_by_entity('election_candidate', 'election_candidate')) {
    return;
  }
  $election = election_load($candidate->election_id);
  if (!$election) {
    watchdog('election_candidate', 'Could not update candidate alias: election ID @id could not be loaded', array('@id' => $candidate->election_id), WATCHDOG_WARNING);
    return;
  }
  module_load_include('inc', 'pathauto');
  pathauto_create_alias(
    'election_candidate',
    $op,
    election_candidate_uri_path($candidate),
    array('election_candidate' => $candidate, 'election' => $election),
    'election_candidate'
  );
}

/**
 * Update the URL aliases for multiple election candidates.
 *
 * @param array $candidate_ids
 *   An array of election candidate IDs.
 * @param string $op
 *   Operation being performed on the candidates ('insert', 'update' or
 *   'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function _election_candidate_pathauto_update_alias_multiple(array $candidate_ids, $op, array $options = array()) {
  $options += array('message' => FALSE);
  $candidates = election_candidate_load_multiple($candidate_ids);
  foreach ($candidates as $candidate) {
    _election_candidate_pathauto_update_alias($candidate, $op, $options);
  }
  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($candidate_ids), 'Updated URL alias for 1 candidate.', 'Updated URL aliases for @count candidates.'));
  }
}

/**
 * Implements hook_views_api().
 */
function election_candidate_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_views_default_views().
 */
function election_candidate_views_default_views() {
  $views_dir = drupal_get_path('module', 'election_candidate') . '/views';
  $views_files = scandir($views_dir);
  $views = array();
  foreach ($views_files as $filename) {
    if (substr($filename, -4) == '.inc') {
      include_once $views_dir . '/' . $filename;
    }
  }
  return $views;
}

/**
 * Load candidates who are standing for the given post.
 *
 * @param stdClass $post
 *   An election post object.
 * @param array $statuses
 *   An array of candidate statuses, by which to filter results (optional).
 * @param bool $only_published
 *   Whether to only find published candidates.
 * @param string $order_by
 *   A database column to order candidates by. Default is random (MySQL RAND()).
 *   Set FALSE for no ordering.
 *
 * @return array
 *   An array of candidate objects keyed by candidate ID.
 */
function election_candidate_load_by_post(stdClass $post, array $statuses = NULL, $only_published = TRUE, $order_by = 'RAND()') {
  $select = db_select('election_candidate', 'ec')
    ->fields('ec', array('candidate_id'))
    ->condition('post_id', $post->post_id);
  if ($only_published) {
    $select->condition('published', 1);
  }
  if ($statuses !== NULL) {
    $select->condition('cstatus', (array) $statuses, 'IN');
  }
  if (!empty($order_by)) {
    $select->orderBy($order_by);
  }
  $candidate_ids = $select->execute()->fetchCol();
  $candidates = election_candidate_load_multiple($candidate_ids);
  return $candidates;
}

/**
 * Implements hook_ENTITY_view_alter().
 */
function election_candidate_election_post_view_alter(&$build) {
  $post = $build['#post'];
  $election = $post->election;
  if (election_candidate_check_support($election) && $build['#view_mode'] == 'full') {
    $candidates_view = views_embed_view('election_candidates', 'embed_candidates_per_post', $post->post_id);
    if (!empty($candidates_view)) {
      $build['candidates'] = array(
        '#prefix' => '<div class="election-post-candidates"><h2>' . t('Candidates') . '</h2>',
        '#markup' => $candidates_view,
        '#suffix' => '</div>',
      );
    }
  }
}

/**
 * Implements hook_action_info().
 */
function election_candidate_action_info() {
  return array(
    'election_candidate_publish_action' => array(
      'type' => 'election_candidate',
      'label' => t('Publish candidate'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
      'triggers' => array('election_candidate_presave'),
    ),
    'election_candidate_unpublish_action' => array(
      'type' => 'election_candidate',
      'label' => t('Unpublish candidate'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
      'triggers' => array('election_candidate_presave'),
    ),
  );
}

/**
 * Publishes a candidate.
 *
 * @ingroup actions
 */
function election_candidate_publish_action($candidate, $context = array()) {
  $candidate->published = 1;
}

/**
 * Unpublishes a candidate.
 *
 * @ingroup actions
 */
function election_candidate_unpublish_action($candidate, $context = array()) {
  $candidate->published = 0;
}

/**
 * Check whether an election type supports candidates.
 */
function election_candidate_check_support(stdClass $election) {
  return (!empty($election->type_info['has candidates']));
}

/**
 * Determine whether the election post has enough candidates for voting.
 *
 * A post needs to have at least 2 published candidates (inc. RON) in order for
 * voting to be possible. Otherwise the candidate is unopposed.
 */
function election_candidate_post_has_enough($post) {
  // Elections that don't support candidates always have 'enough'.
  if (!election_candidate_check_support($post->election)) {
    return TRUE;
  }
  $num_candidates = db_query('SELECT COUNT(candidate_id) FROM {election_candidate} WHERE post_id = :pid AND published = 1', array(':pid' => $post->post_id))->fetchField(0);
  $has_ron = !empty($post->settings['use_ron']);
  return ($num_candidates > 1 || ($num_candidates == 1 && $has_ron));
}

/**
 * Prevent users from accessing vote forms when there aren't enough candidates.
 */
function election_candidate_election_vote_access($op, $post, $account) {
  if (!election_candidate_post_has_enough($post)) {
    return FALSE;
  }
}

/**
 * Generate a table of a user's previous nominations in an election.
 *
 * @param stdClass $election
 *   An election object.
 * @param array $previous_nominations
 *   An array of candidate objects representing the user's previous nominations.
 *
 * @todo make this themeable
 */
function election_candidate_display_previous_nominations(stdClass $election, array $previous_nominations) {
  if (empty($previous_nominations)) {
    return;
  }
  $caption = t('Your previous nominations in this election');
  $header = array(
    t('Nomination date'),
    drupal_ucfirst(election_get_post_name($election->type)),
    t('Candidate name'),
    t('Status'),
  );
  $rows = array();
  foreach ($previous_nominations as $candidate) {
    $post = election_post_load($candidate->post_id);
    $post_title = empty($post) ? '?' : check_plain($post->title);
    $rows[] = array(
      format_date($candidate->created, 'short'),
      $post_title,
      check_plain($candidate->first_name . ' ' . $candidate->last_name),
      theme('election_candidate_status', array('candidate' => $candidate)),
    );
  }
  return array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#caption' => $caption,
  );
}
