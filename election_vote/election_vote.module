<?php
/**
 * @file
 * Election Vote: primary module file.
 */

/**
 * Implements hook_menu().
 */
function election_vote_menu() {
  $items = array();

  $items['election-post/%election_post/vote'] = array(
    'title' => 'Vote',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_vote_form', 1),
    'file' => 'election_vote.forms.inc',
    'access callback' => 'election_vote_access',
    'access arguments' => array('vote', 1),
    'type' => MENU_CALLBACK,
  );

  $items['election-post/%election_post/vote/undo'] = array(
    'title' => 'Undo',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_vote_undo_form', 1),
    'file' => 'election_vote.forms.inc',
    'access callback' => 'election_vote_access',
    'access arguments' => array('undo', 1),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function election_vote_permission() {
  return array(
    'vote in elections' => array(
      'title' => t('Vote in elections'),
      'description' => t('Users must have this permission in order to vote.'),
    ),
    'undo own vote' => array(
      'title' => t('Undo own vote'),
      'description' => t('This allows users to undo their own vote.'),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function election_vote_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_theme().
 */
function election_vote_theme() {
  return array(
    'election_vote_confirm' => array(
      'variables' => array(
        'form_state' => NULL,
      ),
      'file' => 'election_vote.theme.inc',
    ),
    'election_vote_eligibility' => array(
      'variables' => array(
        'post' => NULL,
        'account' => NULL,
      ),
      'file' => 'election_vote.theme.inc',
    ),
    'election_vote_button' => array(
      'variables' => array(
        'post' => NULL,
      ),
      'file' => 'election_vote.theme.inc',
    ),
  );
}

/**
 * Access callback for voting.
 *
 * @param string $op
 *   The operation requested (e.g. 'vote').
 * @param stdClass $post
 *   The election post object.
 */
function election_vote_access($op, stdClass $post, $account = NULL) {
  if (empty($account)) {
    $account = $GLOBALS['user'];;
  }
  // Allow other modules to block access using hook_election_vote_access().
  $hook_results = module_invoke_all('election_vote_access', $op, $post, $account);
  foreach ($hook_results as $hook_result) {
    if ($hook_result === FALSE) {
      return FALSE;
    }
  }
  $election = $post->election;
  switch ($op) {
    case 'vote':
      // Check whether the user can view the post.
      if (!election_post_access('view', $post, $account)) {
        return FALSE;
      }
      // Check whether the election is open.
      if (!_election_is_open($election->vstatus, $election->vopen_time, $election->vclose_time)) {
        return FALSE;
      }
      // Check whether the post is individually set to 'closed'.
      switch ($post->vstatus_inheritance) {
        case ELECTION_POST_STATUS_CLOSED:
          return FALSE;
          break;

      }
      // Check role access.
      $accounts_roles_with_access = array_intersect(array_keys($account->roles), (array) $post->rids);
      if (!count($accounts_roles_with_access)) {
        return FALSE;
      }
      return TRUE;
      break;

    case 'undo':
      // Check global access to undo.
      if (!user_access('undo own vote', $account)) {
        return FALSE;
      }
      // Don't allow undo if the user can no longer vote at all.
      if (!election_vote_access('vote', $post, $account)) {
        return FALSE;
      }
      // The user must have previously voted in order to undo a vote.
      if (!election_vote_check_account_previously_voted($post, $account)) {
        return FALSE;
      }
      return TRUE;
      break;

  }
  return FALSE;
}

/**
 * Implements hook_hook_info().
 */
function election_vote_hook_info() {
  return array(
    'election_vote_access' => array(
      'group' => 'election',
    ),
  );
}

/**
 * Implements hook_entity_delete().
 */
function election_vote_entity_delete($entity, $type) {
  switch ($type) {
    // Delete associated votes when a post is deleted.
    case 'election_post':
      db_query('DELETE FROM {election_vote} WHERE post_id = :pid', array(':pid' => $entity->post_id));
      db_query('DELETE FROM {election_ballot} WHERE post_id = :pid', array(':pid' => $entity->post_id));
      break;

  }
}

/**
 * Find out whether the $account has previously voted regarding this $post.
 *
 * @param stdClass $post
 *   The election post object.
 * @param stdClass $account
 *   Optional user account object (leave blank for the logged-in user).
 *
 * @return bool
 *   TRUE if previously voted, FALSE otherwise.
 */
function election_vote_check_account_previously_voted($post, $account = NULL) {

  global $user;
  if (empty($account)) {
    $account = $user;
  }

  // Determine whether or not we're checking on behalf of the current user.
  $account_is_user = ($account->uid == $user->uid);

  // Build the SQL query, first checking against the UID.
  $query = db_select('election_ballot')
    ->fields('election_ballot', array('ballot_id'))
    ->condition('uid', $account->uid)
    ->condition('post_id', $post->post_id);

  // For anonymous users, check the session ID, or a combination of IP address
  // and user agent. Of course this is not a reliable identifier of a user.
  if ($account_is_user && $account->uid == 0) {
    $query->condition(db_or()
      ->condition('sid_hash', _election_vote_session_hash())
      ->condition(db_and()
        ->condition('ip', ip_address())
        ->condition('agent', $_SERVER['HTTP_USER_AGENT'])
      )
    );
  }

  $result = $query->execute()->fetchCol();

  return !empty($result);

}

/**
 * Get a hash of the session ID, in order to track anonymous users anonymously.
 */
function _election_vote_session_hash() {
  $sid = session_id();
  return md5($sid . $GLOBALS['drupal_hash_salt']);
}

/**
 * Implements hook_html_head_alter().
 */
function election_vote_html_head_alter(&$head_elements) {
  // Prevent search engines from indexing voting forms.
  if (preg_match('/election\-post\/[0-9]+\/vote/', current_path())) {
    foreach ($head_elements as $key => $element) {
      if (isset($element['#atributes']['name']) && $element['#attributes']['name'] == 'robots' && $element['#attributes']['content'] != 'noindex,nofollow') {
        unset($head_elements[$key]);
        break;

      }
    }
    $head_elements['robots'] = array(
      '#type' => 'html_tag',
      '#tag' => 'meta',
      '#attributes' => array('name' => 'robots', 'content' => 'noindex,nofollow'),
    );
  }
}

/**
 * Implements hook_ENTITY_view_alter().
 */
function election_vote_election_post_view_alter(&$build, $type) {
  $post = $build['#post'];
  // Display the vote button and eligibility information on election posts.
  $build['vote_button'] = array(
    '#theme' => 'election_vote_button',
    '#post' => $post,
  );
  $build['eligibility'] = array(
    '#theme' => 'election_info_item',
    '#label' => t('Your eligibility'),
    '#html' => TRUE,
    '#value' => theme('election_vote_eligibility', array('post' => $post)),
  );
}

/**
 * Implements hook_field_extra_fields_alter().
 */
function election_vote_field_extra_fields_alter(&$info) {
  foreach (election_types() as $type) {
    $bundle_name = $type['post machine name'];
    // Add properties to the 'Manage Display' form for election posts.
    $info['election_post'][$bundle_name]['display'] += array(
      'vote_button' => array(
        'label' => t('Vote button'),
        'weight' => -5,
      ),
      'eligibility' => array(
        'label' => t('Eligibility'),
        'weight' => 1,
      ),
    );
  }
}
