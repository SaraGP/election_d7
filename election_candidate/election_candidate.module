<?php
/**
 * @file
 * Election Candidate: primary module file.
 */

// Required files.
require_once 'election_candidate.constants.inc';


/**
 * Implements hook_entity_info().
 */
function election_candidate_entity_info() {

  $entities = array();

  $entities['election_candidate'] = array(
    'label' => t('Election candidate'),
    'access callback' => 'election_candidate_access',
    'uri callback' => 'election_candidate_uri',
    'controller class' => 'ElectionCandidateController',
    'base table' => 'election_candidate',
    'label callback' => 'election_candidate_label',
    'entity keys' => array(
      'id' => 'candidate_id',
      // Candidates are bundled per election.
      'bundle' => 'election_id',
    ),
    'static cache' => TRUE,
    'fieldable' => TRUE,
    'module' => 'election',
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'election_id',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
      ),
      'teaser' => array(
        'label' => t('Teaser'),
      ),
    ),
    // Disable fields added by the Redirect module.
    'redirect' => FALSE,
  );

  return $entities;

}

/**
 * Implements hook_entity_info_alter().
 */
function election_candidate_entity_info_alter(&$entity_info) {
  $election_ids = _election_candidate_get_bundles();
  foreach ($election_ids as $election_id) {
    $entity_info['election_candidate']['bundles'][$election_id] = array(
      'label' => t('Candidate in election @id', array('@id' => $election_id)),
      'admin' => array(
        'path' => 'election/%election/candidates',
        'real path' => 'election/' . $election_id . '/candidates',
        'bundle argument' => 1,
        'access callback' => 'election_candidate_access_per_election',
        'access arguments' => array('administer', 1),
      ),
    );
  }
}

/**
 * Implements hook_permission().
 */
function election_candidate_permission() {
  $permissions = array(
    'administer candidate field settings' => array(
      'title' => t('Administer candidate field settings'),
      'description' => t('This allows the user to manage candidate fields and display settings, if they already have permission to edit the election.'),
    ),
    'bypass nomination schedule' => array(
      'title' => t('Bypass nomination schedule'),
      'description' => t('This allows the user to submit a nomination at any time, regardless of whether or not nominations are open.'),
    ),
    'bypass nomination exclusivity' => array(
      'title' => t('Bypass nomination exclusivity'),
      'description' => t('This allows the user to submit a nomination for more than one exclusive position.'),
    ),
    'allow duplicate nominations' => array(
      'title' => t('Allow duplicate nominations'),
      'description' => t('This allows the user to submit more than one nomination for the same position.'),
    ),
    'submit nominations' => array(
      'title' => t('Submit nominations'),
      'description' => t('This allows the user to submit a nomination, provided nominations are open.'),
    ),
    'edit own nominations' => array(
      'title' => t('Edit own nominations'),
      'description' => t('This allows the user to edit his/her own nominations.'),
    ),
  );
  return $permissions;
}

/**
 * Determines whether the given user has access to a given election candidate.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update').
 * @param stdClass $candidate
 *   Optionally a candidate to check access for. If nothing is
 *   given, access for all candidates is determined.
 * @param stdClass $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not.
 */
function election_candidate_access($op, $candidate = NULL, $account = NULL) {
  if ($account === NULL) {
    $account = $GLOBALS['user'];
  }
  $election = NULL;
  if (!empty($candidate)) {
    $election = election_load($candidate->election_id);
  }
  switch ($op) {
    case 'view':
      // Users who can edit elections can also view the candidates.
      if (election_access('edit', $election, $account)) {
        return TRUE;
      }
      // Users who can view the election can also view approved candidates.
      if (election_access('view', $election, $account) && (empty($candidate) || $candidate->cstatus == ELECTION_CANDIDATE_APPROVED)) {
        return TRUE;
      }
      break;

    case 'edit':
    case 'update':
    case 'delete':
      if (election_access('edit', $election, $account)) {
        return TRUE;
      }
      break;

    case 'view details':
      // 'Details' include personal contact information. Only editors can view.
      if (election_access('edit', $election, $account)) {
        return TRUE;
      }
      break;

    case 'nominate':
      return user_access('submit nominations', $account);
      break;

  }
  // Deal with candidates that belong to the current user.
  $own = ($account->uid != 0 && !empty($candidate) && $candidate->uid == $account->uid);
  if ($own) {
    switch ($op) {
      case 'view':
      case 'view details':
        // Users are always allowed to see their own nominations.
        return TRUE;
        break;

      case 'edit':
      case 'update':
        return (bool) user_access('edit own nominations', $account);
        break;

    }
  }
  return FALSE;
}

/**
 * Helper function to allow determining candidate access per election.
 */
function election_candidate_access_per_election($op, stdClass $election, $account = NULL) {
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  if (empty($election->type_info['has candidates'])) {
    // Ignore if this election type doesn't have candidates.
    return FALSE;
  }
  switch ($op) {
    case 'administer':
      return election_access('edit', $election, $account) && user_access('administer candidate field settings', $account);
      break;

    case 'view':
      return election_access('view', $election, $account);
      break;

    default:
      return election_access('view', $election, $account) && election_candidate_access($op, NULL, $account);
      break;

  }
  return FALSE;
}

/**
 * Implements hook_menu().
 */
function election_candidate_menu() {
  $items = array();

  $items['election/%election/nomination-form'] = array(
    'title' => 'Nomination form',
    'page callback' => 'election_page_nomination_form',
    'page arguments' => array(1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('nominate', 1),
    'file' => 'election-candidate.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 4,
  );

  $items['election/%election/candidates'] = array(
    'title' => 'Candidates',
    'page callback' => 'election_candidate_list_page',
    'page arguments' => array(1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('view', 1),
    'file' => 'election-candidate.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['election/%election/candidates/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['election/%election/candidates/manage'] = array(
    'title' => 'Manage candidates',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_manage_form', 1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('edit', 1),
    'file' => 'election-candidate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['election/%election/candidates/totals'] = array(
    'title' => 'Totals',
    'page callback' => 'election_candidate_totals_page',
    'page arguments' => array(1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('edit', 1),
    'file' => 'election-candidate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['election/%election/candidates/download'] = array(
    'title' => 'Download',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_download_form', 1),
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('edit', 1),
    'file' => 'election-candidate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );


  $items['election-candidate/%election_candidate'] = array(
    'title callback' => 'election_candidate_page_title',
    'title arguments' => array(1),
    'page callback' => 'election_candidate_page_view',
    'page arguments' => array(1),
    'file' => 'election-candidate.pages.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('view', 1),
    'type' => MENU_CALLBACK,
  );

  $items['election-candidate/%election_candidate/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['election-candidate/%election_candidate/details'] = array(
    'title' => 'Details',
    'page callback' => 'election_candidate_details_page_view',
    'page arguments' => array(1),
    'file' => 'election-candidate.pages.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('view details', 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 1,
  );

  $items['election-candidate/%election_candidate/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_edit_form', 1),
    'file' => 'election-candidate.pages.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 2,
  );

  $items['election-candidate/%election_candidate/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_edit_form_delete_confirm', 1),
    'access callback' => 'election_candidate_access',
    'access arguments' => array('delete', 1),
    'file' => 'election-candidate.pages.inc',
    'weight' => 3,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function election_candidate_menu_alter(&$items) {
  $items['election/%election/candidates/fields']['type'] = MENU_LOCAL_TASK;
  $items['election/%election/candidates/fields']['title'] = t('Fields');
  $items['election/%election/candidates/fields']['context'] = MENU_CONTEXT_PAGE;
  $items['election/%election/candidates/fields']['weight'] = 2;
  $items['election/%election/candidates/display']['type'] = MENU_LOCAL_TASK;
  $items['election/%election/candidates/display']['title'] = t('Display');
  $items['election/%election/candidates/display']['context'] = MENU_CONTEXT_PAGE;
  $items['election/%election/candidates/display']['weight'] = 3;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function election_candidate_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Remove the nomination form tab if nominations are closed.
  if (substr($root_path, 0, 10) == 'election/%' && $router_item['map'][0] == 'election') {
    $election = $router_item['map'][1];
    if ($election) {
      $nominations_open = (_election_is_open($election->nstatus, $election->nopen_time, $election->nclose_time) || user_access('bypass nomination schedule'));
      if (!$nominations_open) {
        // @todo can this be simpler or quicker?
        foreach ($data['tabs'][0]['output'] as $key => $tab) {
          if ($tab['#link']['page_callback'] == 'election_page_nomination_form') {
            $data['tabs'][0]['count']--;
            unset($data['tabs'][0]['output'][$key]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_field_extra_fields().
 */
function election_candidate_field_extra_fields() {
  $extra = array(
    'form' => array(
      'post' => array(
        'label' => t('Post'),
        'description' => t('The post for this nomination.'),
        'weight' => 0,
      ),
      'first_name' => array(
        'label' => t('First name'),
        'description' => t("The candidate's first name(s)."),
        'weight' => 1,
      ),
      'last_name' => array(
        'label' => t('Last name'),
        'description' => t("The candidate's last name(s)."),
        'weight' => 2,
      ),
      'mail' => array(
        'label' => t('Email address'),
        'description' => t("The candidate's email address."),
        'weight' => 3,
      ),
      'phone' => array(
        'label' => t('Phone number'),
        'description' => t("The candidate's phone number."),
        'weight' => 4,
      ),
    ),
    'display' => array(
      'election' => array(
        'label' => t('Election'),
        'description' => t('The election for this nomination.'),
        'weight' => 0,
      ),
      'post' => array(
        'label' => t('Post'),
        'description' => t('The post/position for this nomination.'),
        'weight' => 1,
      ),
      'full-name' => array(
        'label' => t('Name'),
        'description' => t("The candidate's full name."),
        'weight' => 2,
      ),
    ),
  );
  // Add the above $extra array to every election_candidate bundle.
  $info['election_candidate'] = array();
  foreach (_election_candidate_get_bundles() as $bundle) {
    $info['election_candidate'][$bundle] = $extra;
  }
  return $info;
}


/**
 * Title callback for election/%election_candidate/view.
 *
 * @param stdClass $candidate
 *   The election candidate object.
 */
function election_candidate_page_title($candidate) {
  // Output should not be escaped here; it is escaped later in the menu system.
  return $candidate->first_name . ' ' . $candidate->last_name;
}

/**
 * Wrapper function to allow saving an election candidate.
 *
 * @param stdClass $candidate
 *   Election candidate object.
 */
function election_candidate_save($candidate) {
  return entity_get_controller('election_candidate')->save($candidate);
}

/**
 * Wrapper function to allow deleting multiple candidates.
 *
 * @param array $candidate_ids
 *   Array of candidate IDs.
 */
function election_candidate_delete_multiple(array $candidate_ids) {
  return entity_get_controller('election_candidate')->delete($candidate_ids);
}

/**
 * Wrapper function to allow deleting an individual election.
 *
 * @see election_candidate_delete_multiple()
 *
 * @param mixed $candidate_id
 *   Single candidate ID.
 */
function election_candidate_delete($candidate_id) {
  return election_candidate_delete_multiple(array($candidate_id));
}


/**
 * Find the nominations (election_candidate entities) for a specified account.
 *
 * @param stdClass $election
 *   Election object.
 * @param stdClass $account
 *   Optional user account object (default: current user).
 *
 * @return mixed
 *   A SelectQuery object. Empty array if the $account is anonymous.
 */
function election_candidate_get_nominations(stdClass $election, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  if ($account->uid == 0) {
    return array();
  }
  $select = db_query(
    'SELECT ec.*, ep.title AS post_title, ep.settings FROM {election_candidate} ec LEFT JOIN {election_post} ep USING (post_id) WHERE ec.uid = :uid AND ep.election_id = :eid',
    array(
      ':eid' => $election->election_id,
      ':uid' => $account->uid,
    )
  );
  return $select->fetchAll();
}

/**
 * Find the posts that a candidate may be nominated for.
 *
 * @param stdClass $election
 *   Election object.
 * @param array $nominations
 *   Array of the user's previous nominations (election_candidate objects).
 * @param stdClass $account
 *   User object.
 *
 * @return array
 *   Array of post IDs.
 */
function election_candidate_get_available_posts(stdClass $election, $nominations = NULL, $account = NULL) {
  if ($account === NULL) {
    global $user;
    $account = $user;
  }
  if ($nominations === NULL) {
    $nominations = election_candidate_get_nominations($election, $account);
  }
  $has_exclusive = FALSE;
  $prev_post_ids = array();
  foreach ($nominations as $nomination) {
    $settings = (array) unserialize($nomination->settings);
    if (!empty($settings['exclusive'])) {
      $has_exclusive = TRUE;
    }
    $prev_post_ids[] = $nomination->post_id;
  }
  $select = db_select('election_post', 'ep')->fields('ep', array('post_id'));
  $select->condition('election_id', $election->election_id, '=');
  if ($prev_post_ids && !user_access('allow duplicate nominations')) {
    $select->condition('post_id', $prev_post_ids, 'NOT IN');
  }
  if ($has_exclusive && !user_access('bypass nomination exclusivity')) {
    $select->condition('exclusive', 0, '=');
  }
  $select->orderBy('title');
  $result = $select->execute();
  return $result->fetchCol();
}

/**
 * URI callback for a single election candidate.
 */
function election_candidate_uri($candidate) {
  $path = 'election-candidate/' . $candidate->candidate_id;
  return array(
    'path' => $path,
    'options' => array(),
  );
}

/**
 * Get the path part of the election candidate URI callback as a string.
 *
 * @see election_candidate_uri()
 */
function election_candidate_uri_path($candidate) {
  $uri = election_candidate_uri($candidate);
  return $uri['path'];
}

/**
 * Entity label callback for an election_candidate.
 */
function election_candidate_label(stdClass $entity, $entity_type) {
  return $entity->first_name . ' ' . $entity->last_name;
}

/**
 * Load an individual election candidate.
 *
 * @param mixed $candidate_id
 *   A single election candidate ID.
 *
 * @return stdClass
 *   A stdClass election_candidate object.
 */
function election_candidate_load($candidate_id = NULL) {
  $result = entity_load('election_candidate', (array) $candidate_id);
  if (!is_array($result) || !count($result)) {
    return FALSE;
  }
  return reset($result);
}

/**
 * Load multiple candidates.
 *
 * @param mixed $candidate_ids
 *   An array of election candidate IDs.
 *
 * @return stdClass
 *   A stdClass election_candidate object.
 */
function election_candidate_load_multiple(array $candidate_ids = array()) {
  return entity_load('election_candidate', $candidate_ids);
}

/**
 * Implements hook_theme().
 */
function election_candidate_theme() {
  return array(
    'election_candidate' => array(
      'render element' => 'elements',
      'template' => 'election-candidate',
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_details' => array(
      'render element' => 'elements',
      'template' => 'election-candidate-details',
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_full_name' => array(
      'variables' => array(
        'candidate' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_ballot_item' => array(
      'variables' => array(
        'candidate' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
  );
}

/**
 * Format the 'cstatus' property of an election_candidate for display.
 */
function _election_candidate_format_status(stdClass $candidate) {
  switch ($candidate->cstatus) {
    case ELECTION_CANDIDATE_APPROVED:
      return t('Approved');
      break;

    case ELECTION_CANDIDATE_REJECTED:
      return t('Nomination rejected');
      break;

    case ELECTION_CANDIDATE_WITHDRAWN:
      return t('Withdrawn');
      break;

    case ELECTION_CANDIDATE_PENDING:
    default:
      return t('Pending approval');
      break;

  }
}

/**
 * Implements hook_entity_update().
 */
function election_candidate_entity_update($entity, $type) {
  switch ($type) {
    case 'election_candidate':
      if (module_exists('pathauto')) {
        _election_candidate_pathauto_update_alias($entity, 'update');
      }
      break;

  }
}

/**
 * Implements hook_entity_delete().
 */
function election_candidate_entity_delete($entity, $type) {
  switch ($type) {

    case 'election':
      $election_id = $entity->election_id;
      // Delete associated candidates when an election is deleted.
      $candidate_ids = db_query('SELECT candidate_id FROM {election_candidate} WHERE election_id = :eid', array(':eid' => $election_id))->fetchCol();
      election_candidate_delete_multiple($candidate_ids);

      // Notify the Field module that this candidate bundle no longer exists.
      field_attach_delete_bundle('election_candidate', $election_id);
      break;

    // Clear the post_id property of candidates when their post is deleted.
    case 'election_post':
      $update = db_update('election_candidate')
        ->fields(array('post_id' => NULL))
        ->condition('post_id', $entity->post_id)
        ->execute();
      break;

    // Delete Pathauto path aliases when a candidate is deleted.
    case 'election_candidate':
      if (function_exists('pathauto_entity_path_delete_all')) {
        pathauto_entity_path_delete_all('election_candidate', $entity);
      }
      break;

  }
}

/**
 * Implements hook_entity_insert().
 */
function election_candidate_entity_insert($entity, $type) {
  switch ($type) {
    case 'election_candidate':
      if (module_exists('pathauto')) {
        _election_candidate_pathauto_update_alias($entity, 'insert');
      }
      break;

    case 'election':
      // Clear the entity info cache.
      // Needed because creating an election also creates candidate bundles.
      entity_info_cache_clear();
      break;

  }
}

/**
 * Implements hook_file_download_access().
 *
 * Allow private files to be downloaded when they are attached to a candidate
 * entity, if the user has permission to view the candidate.
 */
function election_candidate_file_download_access($field, $entity_type, $entity) {
  if ($entity_type == 'election_candidate') {
    return election_candidate_access('view', $entity);
  }
}

/**
 * Update the URL aliases for an individual election candidate.
 *
 * @param stdClass $candidate
 *   An election candidate object.
 * @param string $op
 *   Operation being performed ('insert', 'update' or 'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function _election_candidate_pathauto_update_alias(stdClass $candidate, $op, array $options = array()) {
  // Skip processing if the candidate has no pattern.
  if (!pathauto_pattern_load_by_entity('election_candidate', 'election_candidate')) {
    return;
  }
  $election = election_load($candidate->election_id);
  if (!$election) {
    watchdog('election_candidate', 'Could not update candidate alias: election ID @id could not be loaded', array('@id' => $candidate->election_id), WATCHDOG_WARNING);
    return;
  }
  module_load_include('inc', 'pathauto');
  pathauto_create_alias(
    'election_candidate',
    $op,
    election_candidate_uri_path($candidate),
    array('election_candidate' => $candidate, 'election' => $election),
    'election_candidate'
  );
}

/**
 * Update the URL aliases for multiple election candidates.
 *
 * @param array $candidate_ids
 *   An array of election candidate IDs.
 * @param string $op
 *   Operation being performed on the candidates ('insert', 'update' or
 *   'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function _election_candidate_pathauto_update_alias_multiple(array $candidate_ids, $op, array $options = array()) {
  $options += array('message' => FALSE);
  $candidates = election_candidate_load_multiple($candidate_ids);
  foreach ($candidates as $candidate) {
    _election_candidate_pathauto_update_alias($candidate, $op, $options);
  }
  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($candidate_ids), 'Updated URL alias for 1 candidate.', 'Updated URL aliases for @count candidates.'));
  }
}

/**
 * Implements hook_views_api().
 */
function election_candidate_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_views_default_views().
 */
function election_candidate_views_default_views() {
  $views_dir = drupal_get_path('module', 'election_candidate') . '/views';
  $views_files = scandir($views_dir);
  $views = array();
  foreach ($views_files as $filename) {
    if (substr($filename, -4) == '.inc') {
      include_once $views_dir . '/' . $filename;
    }
  }
  return $views;
}

/**
 * Load candidates who are standing for the given post.
 *
 * @param stdClass $post
 *   An election post object.
 * @param array $statuses
 *   An array of candidate statuses, by which to filter results (optional).
 * @param string $order_by
 *   A database column to order candidates by. Default is random (MySQL RAND()).
 *   Set FALSE for no ordering.
 *
 * @return array
 *   An array of candidate objects keyed by candidate ID.
 */
function election_candidate_load_by_post(stdClass $post, array $statuses = NULL, $order_by = 'RAND()') {
  $select = db_select('election_candidate', 'ec')
    ->fields('ec', array('candidate_id'))
    ->condition('post_id', $post->post_id);
  if ($statuses !== NULL) {
    $select->condition('cstatus', (array) $statuses, 'IN');
  }
  if (!empty($order_by)) {
    $select->orderBy($order_by);
  }
  $candidate_ids = $select->execute()->fetchCol();
  $candidates = election_candidate_load_multiple($candidate_ids);
  return $candidates;
}

/**
 * Count the candidates for a given post.
 *
 * @param string $by
 *   The entity type to filter candidates by ('election' or 'election_post').
 * @param stdClass $entity
 *   Either an election object or an election post object.
 * @param array $statuses
 *   An array of candidate statuses, by which to filter results (optional).
 *
 * @return int
 *   The number of candidates.
 */
function _election_candidate_count($by, stdClass $entity, $statuses = NULL) {
  $candidate_counts = &drupal_static(__FUNCTION__, array());
  $id_field = ($by == 'election') ? 'election_id' : 'post_id';
  $statuses = (array) $statuses;
  $key = $by . '-' . $entity->$id_field  . '-' . implode($statuses);
  if (!isset($candidate_counts[$key])) {
    $select = db_select('election_candidate', 'ec');
    $select->addExpression('COUNT(*)', 'count');
    if (count($statuses)) {
      $select->condition('cstatus', $statuses, 'IN');
    }
    $select->condition($id_field, $entity->$id_field);
    $candidate_counts[$key] = $select->execute()->fetchField();
  }
  return $candidate_counts[$key];
}

/**
 * Implements template_preprocess_election_post().
 */
function election_candidate_preprocess_election_post(&$vars) {
  $post = $vars['elements']['#post'];
  $election = $post->election;
  if (!empty($election->type_info['has candidates'])) {
    $candidates_view = views_embed_view('election_candidates', 'candidates_per_post', $post->post_id);
    if (!empty($candidates_view)) {
      $vars['content']['candidates'] = array(
        '#markup' => '<div class="election-post-candidates"><h2>' . t('Candidates') . '</h2>'
        . $candidates_view
        . '</div>',
        '#weight' => 100,
      );
    }
  }
}

/**
 * Get an array of candidate bundle type machine names.
 *
 * This is effectively an array of election IDs (for now).
 */
function _election_candidate_get_bundles() {
  $bundles = &drupal_static(__FUNCTION__);
  if (!is_array($bundles)) {
    $bundles = array();
    $election_types = election_types();
    $types_with_candidates = array();
    foreach ($election_types as $type => $info) {
      if (!empty($info['has candidates'])) {
        $types_with_candidates[] = $type;
      }
    }
    if (empty($types_with_candidates)) {
      return $bundles;
    }
    $bundles = db_query('SELECT election_id FROM {election} WHERE type IN(:types)', array(':types' => $types_with_candidates))->fetchCol();
  }
  return $bundles;
}

/**
 * Implements hook_action_info().
 */
function election_candidate_action_info() {
  return array(
    'election_candidate_approve_action' => array(
      'type' => 'election_candidate',
      'label' => t('Approve candidate'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
      'triggers' => array('election_candidate_presave'),
    ),
  );
}

/**
 * Sets the status of a candidate to ELECTION_CANDIDATE_APPROVED.
 *
 * @ingroup actions
 */
function election_candidate_approve_action($candidate, $context = array()) {
  $candidate->cstatus = ELECTION_CANDIDATE_APPROVED;
}
